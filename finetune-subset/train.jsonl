{"messages": [{"content": "You are a code autocomplete agent. Users will input partial code snippets, and you will autocomplete the code based on the provided snippet.", "role": "system"}, {"content": "def flow_rect_weir(Height,", "role": "user"}, {"content": "<code>Width): \"\"\"Return the flow of a rectangular weir.\"\"\" #Checking input validity ut.check_range([Height, \">0\", \"Height\"], [Width, \">0\", \"Width\"]) return ((2/3) * con.VC_ORIFICE_RATIO * (np.sqrt(2*gravity.magnitude) * Height**(3/2)) * Width)</code>", "role": "assistant"}]}
{"messages": [{"content": "You are a code autocomplete agent. Users will input partial code snippets, and you will autocomplete the code based on the provided snippet.", "role": "system"}, {"content": "def load_config(self, conf): \"\"\" Load configurations from an rc file Parameters ---------- rc: str path to the rc", "role": "user"}, {"content": "<code>file Returns ------- None \"\"\" section = self.__class__.__name__ if section not in conf.sections(): logger.debug('Config section {} not in rc file'.format( self.__class__.__name__)) return for key in conf[section].keys(): if not hasattr(self, key): logger.debug('Config key {}.{} skipped'.format(section, key)) continue val = conf[section].get(key) try: val = conf[section].getfloat(key) except ValueError: try: val = conf[section].getboolean(key) except ValueError: pass self.__dict__.update({key: val}) self.check()</code>", "role": "assistant"}]}
{"messages": [{"content": "You are a code autocomplete agent. Users will input partial code snippets, and you will autocomplete the code based on the provided snippet.", "role": "system"}, {"content": "def add_dialogue(self, query, response): \"\"\"Add dialogue to", "role": "user"}, {"content": "<code>channel. :param query: query string :param response: response string \"\"\" self._dialogues['__default__'][to_bytes(query)] = to_bytes(response)</code>", "role": "assistant"}]}
{"messages": [{"content": "You are a code autocomplete agent. Users will input partial code snippets, and you will autocomplete the code based on the provided snippet.", "role": "system"}, {"content": "def similarity(self, track): \"\"\" Compares two tracks based on their topology This method compares the given track against this instance. It only verifies if given track is close to this one, not the other way arround Args: track (:obj:`Track`) Returns: Two-tuple with global similarity between tracks and an array the similarity between segments \"\"\" idx = index.Index() i = 0 for i, segment in enumerate(self.segments): idx.insert(i, segment.bounds(), obj=segment) final_siml = [] final_diff = [] for i, segment in enumerate(track.segments): query = idx.intersection(segment.bounds(), objects=True) res_siml = [] res_diff = [] for", "role": "user"}, {"content": "<code>result in query: siml, diff = segment_similarity(segment, result.object) res_siml.append(siml) res_diff.append((result.id, i, diff)) if len(res_siml) > 0: final_siml.append(max(res_siml)) final_diff.append(res_diff[np.argmax(res_siml)]) else: final_siml.append(0) final_diff.append([]) return np.mean(final_siml), final_diff</code>", "role": "assistant"}]}
{"messages": [{"content": "You are a code autocomplete agent. Users will input partial code snippets, and you will autocomplete the code based on the provided snippet.", "role": "system"}, {"content": "def detect(self, volume_system, vstype='detect'): \"\"\"Generator that mounts every partition of this image and yields the mountpoint.\"\"\" # Loop over all volumes in image. for p in self._find_volumes(volume_system, vstype): import pytsk3 volume = volume_system._make_subvolume( index=self._format_index(volume_system, p.addr), offset=p.start * volume_system.disk.block_size, size=p.len * volume_system.disk.block_size ) # Fill volume with more information volume.info['fsdescription'] = p.desc.strip().decode('utf-8') if p.flags == pytsk3.TSK_VS_PART_FLAG_ALLOC: volume.flag = 'alloc' volume.slot = _util.determine_slot(p.table_num, p.slot_num) volume_system._assign_disktype_data(volume) logger.info(\"Found allocated {2}: block offset: {0}, length: {1} \".format(p.start, p.len, volume.info['fsdescription'])) elif p.flags == pytsk3.TSK_VS_PART_FLAG_UNALLOC: volume.flag = 'unalloc' logger.info(\"Found", "role": "user"}, {"content": "<code>unallocated space: block offset: {0}, length: {1} \".format(p.start, p.len)) elif p.flags == pytsk3.TSK_VS_PART_FLAG_META: volume.flag = 'meta' logger.info(\"Found meta volume: block offset: {0}, length: {1} \".format(p.start, p.len)) yield volume</code>", "role": "assistant"}]}
{"messages": [{"content": "You are a code autocomplete agent. Users will input partial code snippets, and you will autocomplete the code based on the provided snippet.", "role": "system"}, {"content": "def _extract_msg_from_last_exception(): ''' Extract a useful error message from the last thrown exception ''' last_exc_type, last_error, last_traceback =", "role": "user"}, {"content": "<code>sys.exc_info() if isinstance(last_error, exceptions.DXAPIError): # Using the same code path as below would not # produce a useful message when the error contains a # 'details' hash (which would have a last line of # '}') return last_error.error_message() else: return traceback.format_exc().splitlines()[-1].strip()</code>", "role": "assistant"}]}
{"messages": [{"content": "You are a code autocomplete agent. Users will input partial code snippets, and you will autocomplete the code based on the provided snippet.", "role": "system"}, {"content": "def get(self, aid): \"\"\" Get manga information by id. :param int aid: ID of the manga. :return: Dictionary or None (for not found) :rtype: Dictionary or None :raises: :class:`Pymoe.errors.ServerError` \"\"\" r = requests.get(self.apiurl + \"/manga/{}\".format(aid), headers=self.header) if r.status_code", "role": "user"}, {"content": "<code>!= 200: if r.status_code == 404: return None else: raise ServerError return r.json()</code>", "role": "assistant"}]}
